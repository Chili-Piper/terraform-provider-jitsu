package resources

import (
	"context"
	"fmt"
	"strings"

	"github.com/chilipiper/terraform-provider-jitsu/internal/client"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

var (
	_ resource.Resource                = &linkResource{}
	_ resource.ResourceWithImportState = &linkResource{}
)

type linkResource struct {
	client *client.Client
}

type linkModel struct {
	WorkspaceID       types.String `tfsdk:"workspace_id"`
	ID                types.String `tfsdk:"id"`
	FromID            types.String `tfsdk:"from_id"`
	ToID              types.String `tfsdk:"to_id"`
	Mode              types.String `tfsdk:"mode"`
	DataLayout        types.String `tfsdk:"data_layout"`
	PrimaryKey        types.String `tfsdk:"primary_key"`
	Frequency         types.Int64  `tfsdk:"frequency"`
	BatchSize         types.Int64  `tfsdk:"batch_size"`
	Deduplicate       types.Bool   `tfsdk:"deduplicate"`
	DeduplicateWindow types.Int64  `tfsdk:"deduplicate_window"`
	SchemaFreeze      types.Bool   `tfsdk:"schema_freeze"`
	TimestampColumn   types.String `tfsdk:"timestamp_column"`
	KeepOriginalNames types.Bool   `tfsdk:"keep_original_names"`
	Functions         types.List   `tfsdk:"functions"`
}

func NewLinkResource() resource.Resource {
	return &linkResource{}
}

func (r *linkResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_link"
}

func (r *linkResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a Jitsu link (connects a stream to a destination). " +
			"The Jitsu link API has no update endpoint, so any attribute change triggers a destroy+create.",
		Attributes: map[string]schema.Attribute{
			"workspace_id": schema.StringAttribute{
				Required:    true,
				Description: "Jitsu workspace ID.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: "Link ID (auto-generated by Console).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"from_id": schema.StringAttribute{
				Required:    true,
				Description: "Source stream ID.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"to_id": schema.StringAttribute{
				Required:    true,
				Description: "Target destination ID.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"mode": schema.StringAttribute{
				Optional:    true,
				Description: "Delivery mode (e.g., batch, stream).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"data_layout": schema.StringAttribute{
				Optional:    true,
				Description: "Data layout (e.g., segment-single-table).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"primary_key": schema.StringAttribute{
				Optional:    true,
				Description: "Comma-separated primary key columns.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"frequency": schema.Int64Attribute{
				Optional:    true,
				Description: "Batch frequency in minutes.",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
			},
			"batch_size": schema.Int64Attribute{
				Optional:    true,
				Description: "Maximum batch size.",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
			},
			"deduplicate": schema.BoolAttribute{
				Optional:    true,
				Description: "Enable deduplication.",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"deduplicate_window": schema.Int64Attribute{
				Optional:    true,
				Description: "Deduplication window in days.",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
			},
			"schema_freeze": schema.BoolAttribute{
				Optional:    true,
				Description: "Freeze schema (prevent new columns).",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"timestamp_column": schema.StringAttribute{
				Optional:    true,
				Description: "Timestamp column name.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"keep_original_names": schema.BoolAttribute{
				Optional:    true,
				Description: "Keep original event property names (no snake_case conversion).",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"functions": schema.ListAttribute{
				Optional:    true,
				ElementType: types.StringType,
				Description: "List of function IDs to apply. Provider adds udf. prefix automatically.",
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (r *linkResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	r.client = configureClient(req, resp)
}

func (r *linkResource) buildPayload(ctx context.Context, plan *linkModel) (map[string]interface{}, error) {
	data := map[string]interface{}{}

	if !plan.Mode.IsNull() && !plan.Mode.IsUnknown() {
		data["mode"] = plan.Mode.ValueString()
	}
	if !plan.DataLayout.IsNull() && !plan.DataLayout.IsUnknown() {
		data["dataLayout"] = plan.DataLayout.ValueString()
	}
	if !plan.PrimaryKey.IsNull() && !plan.PrimaryKey.IsUnknown() {
		data["primaryKey"] = plan.PrimaryKey.ValueString()
	}
	if !plan.Frequency.IsNull() && !plan.Frequency.IsUnknown() {
		data["frequency"] = plan.Frequency.ValueInt64()
	}
	if !plan.BatchSize.IsNull() && !plan.BatchSize.IsUnknown() {
		data["batchSize"] = plan.BatchSize.ValueInt64()
	}
	if !plan.Deduplicate.IsNull() && !plan.Deduplicate.IsUnknown() {
		data["deduplicate"] = plan.Deduplicate.ValueBool()
	}
	if !plan.DeduplicateWindow.IsNull() && !plan.DeduplicateWindow.IsUnknown() {
		data["deduplicateWindow"] = plan.DeduplicateWindow.ValueInt64()
	}
	if !plan.SchemaFreeze.IsNull() && !plan.SchemaFreeze.IsUnknown() {
		data["schemaFreeze"] = plan.SchemaFreeze.ValueBool()
	}
	if !plan.TimestampColumn.IsNull() && !plan.TimestampColumn.IsUnknown() {
		data["timestampColumn"] = plan.TimestampColumn.ValueString()
	}
	if !plan.KeepOriginalNames.IsNull() && !plan.KeepOriginalNames.IsUnknown() {
		data["keepOriginalNames"] = plan.KeepOriginalNames.ValueBool()
	}

	// Transform function IDs: add udf. prefix
	if !plan.Functions.IsNull() && !plan.Functions.IsUnknown() {
		var funcIDs []string
		if diags := plan.Functions.ElementsAs(ctx, &funcIDs, false); diags.HasError() {
			return nil, fmt.Errorf("reading functions: %v", diags.Errors())
		}
		funcs := make([]map[string]string, len(funcIDs))
		for i, fid := range funcIDs {
			funcs[i] = map[string]string{"functionId": "udf." + fid}
		}
		data["functions"] = funcs
	}

	payload := map[string]interface{}{
		"workspaceId": plan.WorkspaceID.ValueString(),
		"type":        "push",
		"fromId":      plan.FromID.ValueString(),
		"toId":        plan.ToID.ValueString(),
		"data":        data,
	}

	return payload, nil
}

func (r *linkResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan linkModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := r.buildPayload(ctx, &plan)
	if err != nil {
		resp.Diagnostics.AddError("Error building payload", err.Error())
		return
	}

	result, err := r.client.Create(ctx, plan.WorkspaceID.ValueString(), "link", payload)
	if err != nil {
		resp.Diagnostics.AddError("Error creating link", err.Error())
		return
	}

	if id, ok := result["id"].(string); ok {
		plan.ID = types.StringValue(id)
	} else {
		resp.Diagnostics.AddError("Missing link ID", "Console did not return an ID for the created link")
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *linkResource) findLinkByID(ctx context.Context, workspaceID, id string) (map[string]interface{}, error) {
	links, err := r.client.List(ctx, workspaceID, "link")
	if err != nil {
		return nil, err
	}
	for _, link := range links {
		linkID, _ := link["id"].(string)
		deleted, _ := link["deleted"].(bool)
		if linkID == id && !deleted {
			return link, nil
		}
	}
	return nil, nil
}

func (r *linkResource) findLink(ctx context.Context, workspaceID, fromID, toID string) (map[string]interface{}, error) {
	links, err := r.client.List(ctx, workspaceID, "link")
	if err != nil {
		return nil, err
	}
	for _, link := range links {
		f, _ := link["fromId"].(string)
		t, _ := link["toId"].(string)
		deleted, _ := link["deleted"].(bool)
		if f == fromID && t == toID && !deleted {
			return link, nil
		}
	}
	return nil, nil
}

func toInt64(v interface{}) (int64, bool) {
	switch n := v.(type) {
	case int:
		return int64(n), true
	case int64:
		return n, true
	case float64:
		return int64(n), true
	default:
		return 0, false
	}
}

func readLinkIntoState(ctx context.Context, link map[string]interface{}, state *linkModel) diag.Diagnostics {
	var diags diag.Diagnostics

	if v, ok := link["id"].(string); ok {
		state.ID = types.StringValue(v)
	}
	if v, ok := link["fromId"].(string); ok {
		state.FromID = types.StringValue(v)
	}
	if v, ok := link["toId"].(string); ok {
		state.ToID = types.StringValue(v)
	}

	data, _ := link["data"].(map[string]interface{})
	if data == nil {
		state.Mode = types.StringNull()
		state.DataLayout = types.StringNull()
		state.PrimaryKey = types.StringNull()
		state.Frequency = types.Int64Null()
		state.BatchSize = types.Int64Null()
		state.Deduplicate = types.BoolNull()
		state.DeduplicateWindow = types.Int64Null()
		state.SchemaFreeze = types.BoolNull()
		state.TimestampColumn = types.StringNull()
		state.KeepOriginalNames = types.BoolNull()
		state.Functions = types.ListNull(types.StringType)
		return diags
	}

	if v, ok := data["mode"].(string); ok {
		state.Mode = types.StringValue(v)
	} else {
		state.Mode = types.StringNull()
	}
	if v, ok := data["dataLayout"].(string); ok {
		state.DataLayout = types.StringValue(v)
	} else {
		state.DataLayout = types.StringNull()
	}
	if v, ok := data["primaryKey"].(string); ok {
		state.PrimaryKey = types.StringValue(v)
	} else {
		state.PrimaryKey = types.StringNull()
	}
	if v, ok := toInt64(data["frequency"]); ok {
		state.Frequency = types.Int64Value(v)
	} else {
		state.Frequency = types.Int64Null()
	}
	if v, ok := toInt64(data["batchSize"]); ok {
		state.BatchSize = types.Int64Value(v)
	} else {
		state.BatchSize = types.Int64Null()
	}
	if v, ok := data["deduplicate"].(bool); ok {
		state.Deduplicate = types.BoolValue(v)
	} else {
		state.Deduplicate = types.BoolNull()
	}
	if v, ok := toInt64(data["deduplicateWindow"]); ok {
		state.DeduplicateWindow = types.Int64Value(v)
	} else {
		state.DeduplicateWindow = types.Int64Null()
	}
	if v, ok := data["schemaFreeze"].(bool); ok {
		state.SchemaFreeze = types.BoolValue(v)
	} else {
		state.SchemaFreeze = types.BoolNull()
	}
	if v, ok := data["timestampColumn"].(string); ok {
		state.TimestampColumn = types.StringValue(v)
	} else {
		state.TimestampColumn = types.StringNull()
	}
	if v, ok := data["keepOriginalNames"].(bool); ok {
		state.KeepOriginalNames = types.BoolValue(v)
	} else {
		state.KeepOriginalNames = types.BoolNull()
	}

	// Transform function IDs: strip udf. prefix
	if funcs, ok := data["functions"].([]interface{}); ok && len(funcs) > 0 {
		funcIDs := make([]string, 0, len(funcs))
		for _, f := range funcs {
			if fm, ok := f.(map[string]interface{}); ok {
				if fid, ok := fm["functionId"].(string); ok {
					funcIDs = append(funcIDs, strings.TrimPrefix(fid, "udf."))
				}
			}
		}
		if len(funcIDs) == 0 {
			state.Functions = types.ListNull(types.StringType)
			return diags
		}
		funcList, d := types.ListValueFrom(ctx, types.StringType, funcIDs)
		diags.Append(d...)
		state.Functions = funcList
	} else {
		state.Functions = types.ListNull(types.StringType)
	}

	return diags
}

func (r *linkResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state linkModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	link, err := r.findLinkByID(ctx, state.WorkspaceID.ValueString(), state.ID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error reading link", err.Error())
		return
	}
	if link == nil {
		resp.State.RemoveResource(ctx)
		return
	}

	resp.Diagnostics.Append(readLinkIntoState(ctx, link, &state)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (r *linkResource) Update(_ context.Context, _ resource.UpdateRequest, resp *resource.UpdateResponse) {
	// All attributes have RequiresReplace â€” this method should never be called.
	resp.Diagnostics.AddError("Unexpected Update", "Link resources do not support in-place updates; all changes require replacement.")
}

func (r *linkResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state linkModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	if err := r.client.DeleteLink(ctx, state.WorkspaceID.ValueString(), state.ID.ValueString()); err != nil {
		resp.Diagnostics.AddError("Error deleting link", err.Error())
	}
}

func (r *linkResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	parts := splitImportID(req.ID, 3)
	if parts == nil {
		resp.Diagnostics.AddError("Invalid import ID", "Expected format: workspace_id/from_id/to_id")
		return
	}

	wsID, fromID, toID := parts[0], parts[1], parts[2]

	link, err := r.findLink(ctx, wsID, fromID, toID)
	if err != nil {
		resp.Diagnostics.AddError("Error importing link", err.Error())
		return
	}
	if link == nil {
		resp.Diagnostics.AddError("Link not found", fmt.Sprintf("Link from %s to %s not found in workspace %s", fromID, toID, wsID))
		return
	}

	state := linkModel{
		WorkspaceID: types.StringValue(wsID),
	}
	resp.Diagnostics.Append(readLinkIntoState(ctx, link, &state)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
