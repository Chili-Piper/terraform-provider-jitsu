# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Terraform/OpenTofu provider for Jitsu (a data ingestion platform). The provider manages Jitsu configuration objects (streams, destinations, functions, and links) via the Jitsu Console API and direct PostgreSQL access.

**Key architectural constraint**: Jitsu uses soft-delete for most operations. When recreating resources with the same ID, the provider must hard-delete soft-deleted rows from the database before POST, otherwise the API returns a unique constraint error.

## Build and Test Commands

Build the provider:
```bash
make build
# or directly: go build -o terraform-provider-jitsu
```

Install locally for testing (creates binary in current directory):
```bash
make install
# Then configure dev_overrides in ~/.tofurc or ~/.terraformrc pointing to this directory
```

Run unit tests:
```bash
make test
# or: go test ./... -v
```

Run acceptance tests (requires environment setup):
```bash
make testacc
# or: TF_ACC=1 go test ./... -v -timeout 120s
```

Run a single test:
```bash
TF_ACC=1 go test ./internal/provider -v -run TestAccFunctionResource
```

## Environment Variables for Testing

Acceptance tests require:
- `JITSU_CONSOLE_URL` - Jitsu Console URL (e.g., http://localhost:3300)
- `JITSU_AUTH_TOKEN` - Bearer token for API authentication (user API key in `keyId:secret` format)
  - Admin tokens don't work due to API limitations (e.g., during workspace creation the API associates it with the user).
- `JITSU_DATABASE_URL` - PostgreSQL connection string to Console's database

## Code Architecture

### Layer Structure

1. **main.go** - Provider entry point, registers the provider with the Terraform plugin framework
2. **internal/provider/** - Provider configuration and resource registration
   - `provider.go` - Provider schema (console_url, auth_token, database_url), configuration, and resource registration
   - `*_test.go` - Acceptance tests using `terraform-plugin-testing` framework
   - `testutil_test.go` - Shared test utilities and provider factory
3. **internal/client/** - HTTP client for Jitsu Console API
   - `client.go` - All API operations (Create/Read/Update/Delete/List) and database hard-delete logic
4. **internal/resources/** - Resource implementations (one per Jitsu object type)
   - `function.go` - JavaScript transformation functions
   - `stream.go` - Data streams with public/private keys
   - `destination.go` - Data sinks (ClickHouse, PostgreSQL, etc.)
   - `link.go` - Connections between streams and destinations (batch/stream mode, functions, deduplication settings)
   - `util.go` - Shared helpers (`splitImportID`, `configureClient`)

### Client Layer Details

The `client.Client` handles:
- HTTP requests to Jitsu Console API with bearer token authentication
- Soft-delete recovery: when POST returns unique constraint error, it hard-deletes the soft-deleted row via direct SQL and retries
- Lazy database connection initialization (only when database_url is configured)
- URL construction for config objects: `/api/{workspaceID}/config/{resourceType}[/{id}]`
- Links use a query parameter for deletion: `/api/{workspaceID}/config/link?id={urlEncodedId}`

### Resource Layer Pattern

All resources follow the same pattern:
1. Implement `resource.Resource` and `resource.ResourceWithImportState` interfaces
2. Define a model struct with `tfsdk` tags mapping to Terraform schema attributes
3. `Create`: Build payload, call `client.Create`, handle soft-delete conflicts automatically
4. `Read`: Call `client.Read`, map response to state, remove resource if not found or soft-deleted
5. `Update`: Build payload, call `client.Update`
6. `Delete`: Call `client.Delete` (soft-delete on Jitsu side)
7. `ImportState`: Parse `workspace_id/resource_id` format, call `client.Read`, populate state

### Resource-Specific Notes

**Functions**: ID must be a valid JavaScript identifier (use underscores, not hyphens). Type is always "function".

**Streams**: Manage public_keys and private_keys as lists of objects with `id` and `plaintext` fields.

**Destinations**: Type-specific configuration varies (e.g., ClickHouse needs protocol/hosts/username/password/database).

**Links**: Complex configuration for data pipeline behavior (mode, data_layout, primary_key, frequency, batch_size, deduplication, schema management). Links reference functions by ID in a list. The link ID is auto-generated by combining from_id and to_id. Delete uses query parameter instead of path parameter.

## Testing Strategy

Acceptance tests (`*_test.go` in `internal/provider/`) use real API calls against a test workspace. Tests typically:
1. Create resource with `resource.Test` and HCL config
2. Verify creation with `resource.TestCheckResourceAttr`
3. Update resource and verify changes
4. Test import with `ImportStateVerify`
5. Clean up automatically via test framework

Use `testWorkspaceID(t)` helper to get workspace ID from environment and skip if not set.

## Provider Configuration in Terraform

```hcl
provider "jitsu" {
  console_url  = "http://localhost:3300"  # or JITSU_CONSOLE_URL
  auth_token   = "keyId:secret"           # or JITSU_AUTH_TOKEN (sensitive)
  database_url = "postgres://..."         # or JITSU_DATABASE_URL (sensitive, optional but recommended)
}
```

The database_url is optional but strongly recommended - without it, recreating resources with the same ID will fail due to soft-delete conflicts.

## Import Format

All resources use `workspace_id/resource_id` format:
```bash
terraform import jitsu_function.example my_workspace/my_function_id
```

## Dependencies

Uses `terraform-plugin-framework` (not the older SDK v2). Key dependencies:
- `github.com/hashicorp/terraform-plugin-framework` - Provider framework
- `github.com/hashicorp/terraform-plugin-log` - Structured logging via `tflog`
- `github.com/hashicorp/terraform-plugin-testing` - Acceptance test framework
- `github.com/lib/pq` - PostgreSQL driver for hard-delete operations

## Local Development Setup

1. Build the provider: `make build`
2. Configure dev_overrides in `~/.tofurc` (OpenTofu) or `~/.terraformrc` (Terraform):
```hcl
provider_installation {
  dev_overrides {
    "chilipiper/jitsu" = "/path/to/terraform-provider-jitsu"
  }
  direct {}
}
```
3. Run `terraform apply` in examples/ directory - it will use your local binary
4. See examples/main.tf for usage examples
